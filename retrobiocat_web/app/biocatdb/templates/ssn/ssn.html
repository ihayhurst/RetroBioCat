{% extends "base.html" %}
{% set active_page = "" %}

{% block content %}
    <style>
        #myssn {
            width: 100%;
            height:87vh;
            background-color: white;
            border: 1px solid lightgray;
            position: relative;
            float: left; }
    </style>

    <div style="overflow-y: hidden; height:90vh">
        {% include 'ssn/ssn_top_bar.html' %}
        <div id="myssn"></div>
    </div>

    {% include 'ssn/modals/network_physics_modal.html' %}
    {% include 'ssn/modals/edit_selected_nodes_modal.html' %}


    <script type="text/javascript">
        // initialize global variables.
        var container = document.getElementById('myssn');

        var edges_options = {'smooth': false}

        var physics_options = {'stabilization': {'enabled': false,
                                                 'iterations': 50},
                                "repulsion": {
                                      "centralGravity": 0.1,
                                      "springLength": 860,
                                      "nodeDistance": 860,
                                      "damping": 0.5
                                },
                                "maxVelocity": 100,
                                "minVelocity": 0.75,
                                "solver": "repulsion",
                                "timestep": 0.75}

        var interaction_options = {'tooltipDelay': 0,
                                   'hideEdgesOnDrag': true}

        var configure_options = {filter: function (option, path) {
                                    if (path.indexOf("physics") !== -1) {
                                        return true;}
                                    if (path.indexOf("smooth") !== -1 || option === "smooth") {
                                        return true;
                                    }
                                    return false;},
                                    container: document.getElementById("ssn_network_config")}


        var options = {edges: edges_options,
                       physics: physics_options,
                       interaction: interaction_options,
                       configure: configure_options,
                      };

        function edgesFilter(edge) {
            return (edge.weight >= document.getElementById("alignment_score").value);
        }

        const max_nodes = {{max_nodes}}
        const cluster_nodes_array = {{cluster_nodes|tojson}}
        const edges = new vis.DataSet({{edges|tojson}})
        const nodes = new vis.DataSet({{nodes|tojson}})
        const edgesView = new vis.DataView(edges, { filter: edgesFilter });
        edgesView.refresh();

        var data = {'nodes': nodes, 'edges': edgesView};

        var network = new vis.Network(container, data, options);

        function parent_child_join_condition(parentNodeOptions, childNodeOptions) {
            var passed = true
            if (parentNodeOptions.node_type === 'biocatdb') {
                passed = false
            }
            if (parentNodeOptions.node_type === 'cluster') {
                passed = false
            }
            if (childNodeOptions.node_type === 'biocatdb') {
                passed = false
            }
            if (childNodeOptions.node_type === 'cluster') {
                passed = false
            }

            return passed;
        }

        function cluster_process_props(clusterOptions, childNodes, childEdges) {
              size = 35
              num_nodes = childNodes.length

              childNodes.forEach(function (item, index) {
                  if (childNodes[index].node_type === 'cluster') {
                      size += childNodes[index]['clustered_nodes'] * 4
                  } else {
                      size += 4
                  }

                  if (childNodes[index].hasOwnProperty('clustered_nodes')) {
                      num_nodes += childNodes[index]['clustered_nodes'] - 1
                  }
              });

              clusterOptions.size = size
              if (clusterOptions.size > 200) {
                  clusterOptions.size = 200
              }

              clusterOptions.label = "# " + num_nodes + "";
              clusterOptions.title = "# " + num_nodes + "";
              clusterOptions.x = childNodes[0].x
              clusterOptions.y = childNodes[0].y
              clusterOptions.clustered_nodes = num_nodes
              clusterOptions.color.background = childNodes[0].color.background
              return clusterOptions
          }

          var default_cluster_props = {
              'borderWidth': 2,
              'borderWidthSelected': 3,
              'color': {'border': 'darkgrey'},
              'shape': 'dot',
              'node_type': 'cluster',
          }

        var cluster_by_connection_options = {
          joinCondition: parent_child_join_condition,
          processProperties: cluster_process_props,
          clusterNodeProperties: default_cluster_props
        }


        network.on("doubleClick", function (params) {
            console.log(params)
            if (params.nodes.length === 1) {
                if (network.isCluster(params.nodes[0]) === true) {
                    network.openCluster(params.nodes[0]);
                } else {
                    network.clustering.clusterByConnection(params.nodes[0], cluster_by_connection_options)
                }
            }
        });

        document.getElementById("alignment_score").onchange = function(){
            edgesView.refresh()
        }

        function cluster_by_hubsize() {
            network.clustering.clusterByHubsize(cluster_options)
        }


        function get_new_connected_nodes(nodes_array, selected_nodes) {
            var new_connected_nodes = []
            nodes_array.forEach(function (sel_node, i) {
                var connected_nodes = network.getConnectedNodes(sel_node)
                connected_nodes.forEach(function (con_node, j) {
                    if (selected_nodes.includes(con_node) === false) {
                        new_connected_nodes.push(con_node)
                    }
                })
            })
            return new_connected_nodes
        }

        function select_connected_nodes() {
            var selected_nodes = network.getSelectedNodes()
            var new_nodes_array = network.getSelectedNodes()
            while (new_nodes_array.length !== 0) {
                new_nodes_array = get_new_connected_nodes(new_nodes_array, selected_nodes)
                selected_nodes = selected_nodes.concat(new_nodes_array)
                console.log('selected_nodes:')
                console.log(selected_nodes)
            }
            network.selectNodes(selected_nodes)
        }

        function cluster_join_condition(nodeOptions) {

            }

        function cluster_nodes(central_node) {
            var cluster_options = {
                joinCondition: function(nodeOptions) {
                    if (nodeOptions.cluster_group === ''+central_node) {
                        return true
                    }
                    return false
                },
                processProperties: cluster_process_props,
                clusterNodeProperties: default_cluster_props
            }
            network.cluster(cluster_options)
        }

        while ((max_nodes > network.body.nodes.length) || (cluster_nodes_array.length !== 0)) {
            cluster_nodes(cluster_nodes_array[0])
            cluster_nodes_array.shift()
        }

    </script>

{% endblock %}
