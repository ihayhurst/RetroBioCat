{% extends "base.html" %}
{% set active_page = "" %}

{% block content %}
    <style>
        #myssn {
            width: 100%;
            height:87vh;
            background-color: white;
            border: 1px solid lightgray;
            position: relative;
            float: left; }
    </style>

    <div style="overflow-y: hidden; height:90vh">
        {% include 'ssn/ssn_top_bar.html' %}
        <div id="myssn"></div>
    </div>

    {% include 'ssn/modals/network_physics_modal.html' %}
    {% include 'ssn/modals/edit_selected_nodes_modal.html' %}


    <script type="text/javascript">
        // initialize global variables.
        var container = document.getElementById('myssn');

        var edges_options = {'smooth': false}

        var physics_options = {'stabilization': {'enabled': true,
                                                 'iterations': 50},
                                "repulsion": {
                                   "centralGravity": 0.1,
                                   "nodeDistance": 500
                                },
                                "maxVelocity": 49,
                                "minVelocity": 0.75,
                                "solver": "repulsion",
                                "timestep": 0.75}

        var interaction_options = {'tooltipDelay': 0,
                                   'hideEdgesOnDrag': true}


        var options = {edges: edges_options,
                       physics: physics_options,
                       interaction: interaction_options,
                       configure: {filter: function (option, path) {
                                    if (path.indexOf("physics") !== -1) {
                                        return true;}
                                    if (path.indexOf("smooth") !== -1 || option === "smooth") {
                                        return true;
                                    }
                                    return false;},
                                    container: document.getElementById("ssn_network_config")},
                      };

        function edgesFilter(edge) {
            return (edge.weight >= document.getElementById("alignment_score").value);
        }

        const edges = new vis.DataSet({{edges|tojson}})
        const nodes = new vis.DataSet({{nodes|tojson}})
        const edgesView = new vis.DataView(edges, { filter: edgesFilter });
        edgesView.refresh();

        var data = {'nodes': nodes, 'edges': edgesView};

        var network = new vis.Network(container, data, options);

        var cluster_options = {
          joinCondition:function(parentNodeOptions, childNodeOptions) {
              var passed = true
              if (parentNodeOptions.node_type === 'biocatdb') {
                  passed = false
              }
              if (parentNodeOptions.node_type === 'cluster') {
                  passed = false
              }
              if (childNodeOptions.node_type === 'biocatdb') {
                  passed = false
              }
              if (childNodeOptions.node_type === 'cluster') {
                  passed = false
              }

              return passed;
          },
          processProperties: function (clusterOptions,
            childNodes, childEdges) {
              size = 35
              num_nodes = childNodes.length

              childNodes.forEach(function (item, index) {
                  if (childNodes[index].node_type === 'cluster') {
                      size += childNodes[index]['clustered_nodes'] * 4
                  } else {
                      size += 4
                  }

                  if (childNodes[index].hasOwnProperty('clustered_nodes')) {
                      num_nodes += childNodes[index]['clustered_nodes'] - 1
                  }
              });

              clusterOptions.size = size
              if (clusterOptions.size > 200) {
                  clusterOptions.size = 200
              }

              clusterOptions.label = "# " + num_nodes + "";
              clusterOptions.title = "# " + num_nodes + "";
              clusterOptions.x = childNodes[0].x
              clusterOptions.y = childNodes[0].y
              clusterOptions.clustered_nodes = num_nodes
              clusterOptions.color.background = childNodes[0].color.background
              return clusterOptions
          },
          clusterNodeProperties: {
              'borderWidth': 2,
              'borderWidthSelected': 3,
              'color': {'border': 'darkgrey'},
              'shape': 'dot',
              'node_type': 'cluster',
          }
        }


        network.on("doubleClick", function (params) {
            console.log(params)
            if (params.nodes.length === 1) {
                if (network.isCluster(params.nodes[0]) === true) {
                    network.openCluster(params.nodes[0]);
                } else {
                    network.clustering.clusterByConnection(params.nodes[0], cluster_options)
                }
            }
        });

        document.getElementById("alignment_score").onchange = function(){
            edgesView.refresh()
        }

        function cluster_by_hubsize() {
            network.clustering.clusterByHubsize(cluster_options)
        }


        function get_new_connected_nodes(nodes_array, selected_nodes) {
            var new_connected_nodes = []
            nodes_array.forEach(function (sel_node, i) {
                var connected_nodes = network.getConnectedNodes(sel_node)
                connected_nodes.forEach(function (con_node, j) {
                    if (selected_nodes.includes(con_node) === false) {
                        new_connected_nodes.push(con_node)
                    }
                })
            })
            return new_connected_nodes
        }

        function select_connected_nodes() {
            var selected_nodes = network.getSelectedNodes()
            var new_nodes_array = network.getSelectedNodes()
            while (new_nodes_array.length !== 0) {
                new_nodes_array = get_new_connected_nodes(new_nodes_array, selected_nodes)
                selected_nodes = selected_nodes.concat(new_nodes_array)
                console.log('selected_nodes:')
                console.log(selected_nodes)
            }
            network.selectNodes(selected_nodes)
        }


    </script>

{% endblock %}
